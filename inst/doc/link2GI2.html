<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>link2GI Basic Examples</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/github.min.css">
<script src="https://cdn.jsdelivr.net/combine/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js,npm/@xiee/utils/js/load-highlight.js" async></script>



<style type="text/css">
body, td {
  font-family: sans-serif;
  background-color: white;
  font-size: 13px;
}
body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
tt, code, pre {
  font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}
a:visited { color: #80007f; }
pre, img { max-width: 100%; }
code {
  font-size: 92%;
  border: 1px solid #ccc;
}
code[class] { background-color: #F8F8F8; }
code.language-undefined { background-color: inherit; }
table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color:#666;
  margin:0;
  padding-left: 1em;
  border-left: 0.5em #eee solid;
}
hr { border: 1px #ddd dashed; }

@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
  }
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  a, a:visited { text-decoration: underline; }
  hr {
    visibility: hidden;
    page-break-before: always;
  }
  pre, blockquote {
    padding-right: 1em;
    page-break-inside: avoid;
  }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style>



</head>

<body>
<h1>Usage of the link2GI package - Basic Examples</h1>
<h2>Brute force search usage</h2>
<p>Automatic search and find of the installed GIS software binaries is performed by the <code>find</code> functions. Depending of you OS and the number of installed versions you will get a dataframe providing the binary and module folders.</p>
<pre><code class="language-r"># find all SAGA GIS installations at the default search location
require(link2GI)
saga &lt;- link2GI::findSAGA()
saga
</code></pre>
<p>Same with <code>GRASS</code> and <code>OTB</code></p>
<pre><code class="language-r"># find all SAGA GIS installations at the default search location
require(link2GI)
grass &lt;- link2GI::findGRASS()
grass
otb &lt;- link2GI::findOTB()
otb
</code></pre>
<p>The <code>find</code> functions are providing an overview of the installed software. This functions are not establishing any linkages or changing settings.</p>
<h2>Setting up project structures</h2>
<p>If you just call link2GI on the fly , that means for a single temporary operation, there will be no need for setting up folders and project structures. If you work on a more complex project it is seems to be helpful to support this by a fixed structure. Same with existing <code>GRASS</code> projects wich need to be in specific mapsets and locations.</p>
<p>A straightforward  (you may call it also dirty) approach is the ìnitProj`function that creates folder structures (if not existing) and establishes (if wanted) global variables containing the pathes as strings.</p>
<pre><code class="language-r"># find all SAGA GIS installations at the default search location
require(link2GI)
link2GI::initProj(projRootDir = tempdir(),
                 projFolders = c(&quot;data/&quot;,
                                 &quot;data/level0/&quot;,
                                 &quot;data/level1/&quot;,
                                  &quot;output/&quot;,
                                  &quot;run/&quot;,
                                  &quot;fun/&quot;),
                 path_prefix = &quot;path_to_&quot; ,
                 global =TRUE)
</code></pre>
<h2>linkSAGA - Locate and set up ‘SAGA’ API bindings</h2>
<p>In earlier times it has been pretty cumbersome to link the correct <code>SAGA GIS</code> version. Since the version 1.x.x  of <code>RSAGA</code> things turned much better. The new <code>RSAGA::rsaga.env()</code> function is at getting the first <code>RSAGA</code> version in the search path. For using <code>RSAGA</code> with <code>link2GI</code> it is strongly recommended to call <code>RSAGA.env()</code> with the preferred path as provided by a ’  <code>findSAGA()</code> call. It is also possible to provide the version number as shown below. Storing the result in adequate variables will then even give  the opportunity to easyly switch  between different <code>SAGA GIS</code> installations.</p>
<pre><code class="language-r">saga1&lt;-link2GI::linkSAGA(ver_select = 1) 
saga1
sagaEnv1&lt;- RSAGA::rsaga.env(path = saga1$sagaPath)
</code></pre>
<h2>linkGRASS - Locate and set up ‘GRASS ⅞’ API bindings</h2>
<p><code>linkGRASS</code> Initializes the session environment and the system paths for an easy access to <code>GRASS GIS 7.x./8.x</code> The correct setup of the spatial and projection parameters is automatically performed by using either an existing and valid <code>raster</code> or <code>terra</code> , <code>sp</code> or <code>sf</code> object, or manually by providing a list containing the minimum parameters needed. These properties are used to initialize either a temporary or a permanent <code>rgrass</code> environment including the correct <code>GRASS 7/8</code> database structure. If you provide none of the before mentioned objects <code>linkGRASS</code> will create a EPSG:4326 world wide location.</p>
<p>The most time consuming part on ‘Windows’ Systems is the search process. This can easily take 10 or more minutes. To speed up this process you can also provide a correct parameter set. Best way to do so is to call manually <code>findGRASS</code>. Then call <code>linkGRASS</code> with the returned version arguments of your choice.</p>
<p>The function <code>linkGRASS</code> tries to find all valid  <code>GRASS GIS</code> binaries by analyzing the startup script files of <code>GRASS GIS</code>. After identifying the <code>GRASS GIS</code> binaries all necessary system variables and settings will be generated and passed to a temporary <code>R</code> environment.</p>
<p>If you have more than one valid installation and run <code>linkGRASS</code> with the  arguments <code>select_ver = TRUE</code>, then you will be ask to select one.</p>
<h4>Standard Full Search Usage</h4>
<p>The most common way to use <code>GRASS</code> is just for one call or algorithm. So the user is not interested in the cumbersome setting up of all parameters. <code>linGRASS7(georeferenced-dataset)</code> does an automatic search and find all <code>GRASS</code> binaries using the georeferenced-dataset object for spatial referencing and the necessary other settings.
<strong>NOTE:</strong> This is the highly recommended linking procedure for all on the fly calls of <code>GRASS</code>. Please note also: If more than one <code>GRASS</code> installation is found the one with the highest version number is selected automatically.</p>
<p>Have a look at the following examples which show a typical call for  the well known <code>sp</code>and <code>sf</code> vector data objects.</p>
<p>Starting with <code>sp</code>.</p>
<pre><code class="language-r"># get meuse data as sp object and link it temporary to GRASS
require(link2GI)
require(sp)

# get data 
data(meuse) 
# add georeference
coordinates(meuse) &lt;- ~x+y 
proj4string(meuse) &lt;-CRS(&quot;+init=epsg:28992&quot;) 

# Automatic search and find of GRASS binaries
# using the meuse sp data object for spatial referencing
# This is the highly recommended linking procedure for on the fly jobs
# NOTE: if more than one GRASS installation is found the highest version will be choosed

linkGRASS(meuse)
</code></pre>
<p>Now do the same with  <code>sf</code> based data.</p>
<pre><code class="language-r"> require(link2GI)
 require(sf)

 # get  data
 nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;))

 # Automatic search and find of GRASS binaries
 # using the nc sf data object for spatial referencing
 # This is the highly recommended linking procedure for on the fly jobs
 # NOTE: if more than one GRASS installation is found the highest version will be choosed
 
 grass&lt;-linkGRASS(nc,returnPaths = TRUE)
</code></pre>
<p>The second most common situation is the usage of an existing <code>GRASS</code> location and project either with existing data sets or manually provided parameters.</p>
<pre><code class="language-r">  library(link2GI)
 require(sf)

 # proj folders
 projRootDir&lt;-tempdir()
 paths&lt;-link2GI::initProj(projRootDir = projRootDir,
                          projFolders = c(&quot;project1/&quot;))

 # get  data
 nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;))

 # CREATE and link to a permanent GRASS folder at &quot;projRootDir&quot;, location named &quot;project1&quot;
 linkGRASS(nc, gisdbase = projRootDir, location = &quot;project1&quot;)

 # ONLY LINK to a permanent GRASS folder at &quot;projRootDir&quot;, location named &quot;project1&quot;
 linkGRASS(gisdbase = projRootDir, location = &quot;project1&quot;, gisdbase_exist = TRUE )


 # setting up GRASS manually with spatial parameters of the nc data
 proj4_string &lt;- as.character(sp::CRS(&quot;+init=epsg:28992&quot;))
 linkGRASS(spatial_params = c(178605,329714,181390,333611,proj4_string))

 # creating a GRASS gisdbase manually with spatial parameters of the nc data
 # additionally using a peramanent directory &quot;projRootDir&quot; and the location &quot;nc_spatial_params &quot;
 proj4_string &lt;- as.character(sp::CRS(&quot;+init=epsg:4267&quot;))
 linkGRASS(gisdbase = projRootDir,
            location = &quot;nc_spatial_params&quot;,
            spatial_params = c(-84.32385, 33.88199,-75.45698,36.58965,proj4_string))
</code></pre>
<h4>Typical for specified search pathes and OS</h4>
<p>The full disk search can be cumbersome especially running Windos it can easily take 10 minutes and more. So it is helpful to provide a searchpath for narrowing down the search. Searching for <code>GRASS</code> installations in the home directory you may use the following command.</p>
<pre><code class="language-r"># Link the GRASS installation and define the search location
 linkGRASS(nc, search_path = &quot;~&quot;)
</code></pre>
<p>If  you already did a full search and kow your installation fo example using the command <code>findGRASS</code> you can use the result directly for linking.</p>
<pre><code class="language-r">findGRASS()
     instDir version installation_type
1 /opt/grass   7.8.1           grass78

# now linking it 
linkGRASS(nc,c(&quot;/opt/grass&quot;,&quot;7.8.15&quot;,&quot;grass78&quot;)) 

# corresponding linkage running windows
linkGRASS(nc,c(&quot;C:/Program Files/GRASS GIS7.0.5&quot;,&quot;GRASS GIS 7.0.5&quot;,&quot;NSIS&quot;)) 
</code></pre>
<h4>Manual choosing the version</h4>
<p>Finally some more specific examples related to interactive selection or OS specific settings.
Choose manually the <code>GRASS</code> installation  additionally using the meuse <code>sf</code> object for spatial referencing</p>
<pre><code class="language-r">linkGRASS(nc, ver_select = TRUE)
</code></pre>
<h4>Creating a permanent gisbase folder</h4>
<p>Creating and linking a  permanent <code>GRASS</code> gisdbase (folder structure) at “~/temp3” with the standard mapset “PERMANENT”” and the location named “project1”. For all spatial attributes use the the meuse <code>sf</code> object.</p>
<pre><code class="language-r">linkGRASS(x = nc, 
                     gisdbase = &quot;~/temp3&quot;,
                     location = &quot;project1&quot;)   
</code></pre>
<h4>Using a Permanent gisbase folder</h4>
<p>Link to the permanent <code>GRASS</code> gisdbase (folder structure) at “~/temp3” with the standard mapset “PERMANENT” and the location named “project1”. For all spatial attributes use the formerly referencend nc <code>sf</code> object parameter.</p>
<pre><code class="language-r">linkGRASS(gisdbase = &quot;~/temp3&quot;, location = &quot;project1&quot;, 
                     gisdbase_exist = TRUE)   
</code></pre>
<h4>Manual Setup of the spatial attributes</h4>
<p>Setting up <code>GRASS</code> manually with spatial parameters of the meuse data</p>
<pre><code class="language-r"> linkGRASS(spatial_params = c(178605,329714,181390,333611,
                              &quot;+proj=sterea +lat_0=52.15616055555555 
                               +lon_0=5.38763888888889 +k=0.9999079 
                               +x_0=155000 +y_0=463000 +no_defs 
                               +a=6377397.155 +rf=299.1528128
                               +towgs84=565.4171,50.3319,465.5524,
                                -0.398957,0.343988,-1.8774,4.0725
                               +to_meter=1&quot;)) 
</code></pre>
<h2>A typical usecase for the Orfeo Toolbox wrapper</h2>
<p>link2GI supports the use of the Orfeo Toolbox with a listbased simple wrapper function. Actually two functions parse the modules and functions syntax dumps and generate a command list that is easy to modify with the necessary arguments.</p>
<p>Usually you have to get the module list first:</p>
<pre><code class="language-r"># link to the installed OTB 
otblink&lt;-link2GI::linkOTB()


# get the list of modules from the linked version
algo&lt;-parseOTBAlgorithms(gili = otblink)
</code></pre>
<p>Based on the modules of the current version of <code>OTB</code> you can then choose the module(s) you want to use.</p>
<pre><code class="language-r">## for the example we use the edge detection, 
algoKeyword&lt;- &quot;EdgeExtraction&quot;

## extract the command list for the choosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## print the current command
print(cmd)
</code></pre>
<p>Admittedly this is a very straightforward and preliminary approach. Nevertheless it provids you a valid list of all <code>OTB</code> API calls that can easily manipulated for your needs. The following working example will give you an idea how to use it.</p>
<pre><code class="language-r">require(link2GI)
require(terra)
require(listviewer)

otblink&lt;-link2GI::linkOTB()
 projRootDir&lt;-tempdir()
 
data('rgb', package = 'link2GI')  
terra::plotRGB(rgb)
r&lt;-terra::writeRaster(rgb, 
              filename=file.path(projRootDir,&quot;test.tif&quot;),
              format=&quot;GTiff&quot;, overwrite=TRUE)
## for the example we use the edge detection, 
algoKeyword&lt;- &quot;EdgeExtraction&quot;

## extract the command list for the choosen algorithm 
cmd&lt;-parseOTBFunction(algo = algoKeyword, gili = otblink)

## get help using the convenient listviewer
listviewer::jsonedit(cmd$help)

## define the mandantory arguments all other will be default
cmd$input  &lt;- file.path(projRootDir,&quot;test.tif&quot;)
cmd$filter &lt;- &quot;touzi&quot;
cmd$channel &lt;- 2
cmd$out &lt;- file.path(projRootDir,paste0(&quot;out&quot;,cmd$filter,&quot;.tif&quot;))

## run algorithm
retStack&lt;-runOTB(cmd,gili = otblink)

## plot filter raster on the green channel
plot(retStack)
</code></pre>


<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/center-img.min.js" async></script>
</body>

</html>
